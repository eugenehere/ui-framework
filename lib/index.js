let view = {}

const componentsHierarchy = {}

function render(component) {
  module.rootElement.innerHTML = component._html
}

function randomId(length = 6) {
  return Math.random().toString(36).substring(2, length+2)
}

function evaluateInContext(expression, context) {
  // todo remove view and other external variables from this context
  return (function ({ state, attributes }) {
    return eval(expression) || ""
  })(context)
}

function evaluateExpression(template, context) {
  const result = {
    html: template,
    evaluated: false,
  }

  let indexOpen = template.indexOf('{{')
  if (indexOpen < 0) return result

  const indexClose = template.indexOf('}}')
  if (indexClose < 0) throw new Error('Template parsing failed.')

  const expressionQuoted = template.substring(indexOpen, indexClose + 2)
  const expression = expressionQuoted.substring(2, expressionQuoted.length - 3)

  result.html = template.replace(expressionQuoted, evaluateInContext(expression, context))
  result.evaluated = true
  return result
}

function evaluateExpressions(component) {
  let result = { html: component._template }

  const context = {
    attributes: component._attributes,
    state: component._state,
  }

  do {
    result = evaluateExpression(result.html, context)
  } while (result.evaluated)

  component._html = result.html
}

function parseAttributesString(string) {
  // string: param1="val1" param2="val2"
  const result = {}
  string = string.trim()

  const indexStart = string.indexOf('="')
  const attrName = string.substring(0, indexStart)
  const indexEnd = string.indexOf('"', indexStart + 2)
  result[attrName] = string.substring(indexStart + 2, indexEnd)

  const rest = string.substring(indexEnd + 1, string.length).trim()
  if (!rest || !rest.length) return result

  return {
    ...result,
    ...parseAttributesString(rest)
  }
}

function setupChildren(component) {
  for (const childPath of component._depends) {
    const prefix = '<' + getNameByPath(childPath) + ' '
    const postfix = '/>'

    const childComponentMatches = component._html.match(new RegExp(prefix + '.*' + postfix, 'g')) || []

    const childComponents = childComponentMatches.map(match => {
      const attributesString = match.substring(prefix.length, match.length - postfix.length).trim()
      const attributes = parseAttributesString(attributesString)
      const internals = { ...componentInternals, attributes }

      const childComponent = _setupComponent(childPath, internals)

      component._html = component._html.replace(match, childComponent._html)

    })

  }
}

function parseEventListeners(component) {
  const listeners = []
  if (!component._html) return listeners
  const matches = component._html.match(new RegExp('on:[a-z]+=".*"', 'g')) || []
  matches.map(match => {
    const [_, type, methodName] = match.match('on:([a-z]+)="(.*)"')
    const selector = '_autogenerated_' + randomId(10)
    if (!component[methodName]) throw new Error('Method ' + methodName + ' is not defined.')

    component._html = component._html.replace(match, `id="${selector}"`)

    listeners.push({ type, selector: '#' + selector, callback: component[methodName].bind(component) })
  })

  return listeners
}

function addEventListener(listener) {  
  module.rootElement.querySelector(listener.selector)?.addEventListener(listener.type, listener.callback)
}

const componentInternals = {
  path: '',
  template: '',
  depends: [], // array of component paths (unique) it depends on
  attributes: {}, // external attributes
  state: {},
  loaded: function() {},
  updated: function() {},
  setState: function(callback) {
    callback(this._state)

    evaluateExpressions(this)

    setupChildren(this)

    const listeners = parseEventListeners(this)
  
    render(this)

    listeners.forEach(addEventListener)

    this._updated()
  },
  // onClick: function(selector, callback) {
  //   // todo constrain scope of selectors to the component
  //   module.rootElement.querySelector(selector)?.addEventListener('click', callback)
  // },
  loadView: function(viewName) {
    view = _setupComponent(`views/${viewName}`, { ...componentInternals })
    const listeners = parseEventListeners(view)
    render(view)
    listeners.forEach(addEventListener)
    view._loaded()
  },
}

// const userDefinedInternals = ['template', 'depends', 'state', 'loaded', 'updated']
// const prefixed = name => '_' + name
const getNameByPath = (path) => path.split('/').pop()

function _setupComponent(path, properties) {
  const component = require(path)
  // todo make internals immutable via .defineProperty
  component._path = path
  component._name = getNameByPath(path)
  component._setState = properties.setState
  component._onClick = properties.onClick
  component._loadView = properties.loadView

  const wrapTemplate = (component) => `<div id="_component_${component._name}">${component._template}</div>`

  if (!component._template) {
    component._template = properties.template
  }

  component._template = wrapTemplate(component)

  if (!component._depends || typeof component._depends !== 'object') {
    component._depends = [...properties.depends]
  }

  if (!component._state || typeof component._state !== 'object') {
    component._state = { ...properties.state }
  }

  if (!component._loaded || typeof component._loaded !== 'function') {
    component._loaded = properties.loaded
  }

  if (!component._updated || typeof component._updated !== 'function') {
    component._updated = properties.updated
  }

  if (component._attributes && typeof component._attributes === 'object') {
    component._attributes = Object.keys(component._attributes).reduce((result, attrName) => {
      const defaultValue = component._attributes[attrName]

      result[attrName] = properties.attributes[attrName] || defaultValue

      return result
    }, {})
  }

  evaluateExpressions(component)

  setupChildren(component)

  return component
}

componentInternals.loadView('home')
